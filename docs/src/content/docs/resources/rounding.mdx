---
title: On rounding of intervals
description: Details on the way we round operations in cuinterval
---

import { Image } from 'astro:assets';
import { CardGrid, Card } from '@astrojs/starlight/components';
import { ThemeImage } from '@components';

import evenLeft     from "@assets/rounding/rounding-to-nearest-one-error-closer-to-even-left.webp";
import evenRight    from "@assets/rounding/rounding-to-nearest-one-error-closer-to-even-right.webp";
import oddLeft      from "@assets/rounding/rounding-to-nearest-one-error-closer-to-odd-left.webp";
import oddRight     from "@assets/rounding/rounding-to-nearest-one-error-closer-to-odd-right.webp";
import exactEven    from "@assets/rounding/rounding-to-nearest-one-error-exact-even.webp";
import exactOdd     from "@assets/rounding/rounding-to-nearest-one-error-exact-odd.webp";
import halfwayAbove from "@assets/rounding/rounding-to-nearest-one-error-halfway-odd-above.webp";
import halfwayBelow from "@assets/rounding/rounding-to-nearest-one-error-halfway-odd-below.webp";

CuInterval makes use of the [built-in CUDA math functions](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#mathematical-functions-appendix) which use round-to-nearest-even.
Since some math functions are not fully accurate up to machine presicion -- they do not conform to [IEEE754](https://en.wikipedia.org/wiki/IEEE_754) -- we have to perform additional outward rounding to cover the worst-cases of the specified maximum ulp-error of an intrinsic function.

:::note
Outward rounding applies rounding towards -∞ for lower bounds and rounding towards +∞ for upper bounds.
Since most math functions do not have corresponing operations that round towards ±∞, we make use of nextafter(x, ±∞). Sometimes, we know that the function is bounded (e.g., $$x^2 > 0$$). In those cases, we apply `nextafter(x, 0)` or similar tighter outward roundings whenever possible.
:::

The CUDA math functions use round-to-nearest-even and thus pick the even floating point number if the number would land exactly between two floating point values, otherwise it picks the nearest available value between two floating point values.

If the intrinsic function has a reported max. error of 1 ulp, then the resulting interval output will have a max. error of 2.5 ulps. To see why, let's look at all the scenarios that could be possible:

<CardGrid columns="2">
  <ThemeImage src={evenLeft} alt="Rounding to nearest one error closer to even left." />
  <ThemeImage src={evenRight} alt="Rounding to nearest one error closer to even right." />
  <ThemeImage src={oddLeft} alt="Rounding to nearest one error closer to odd left." />
  <ThemeImage src={oddRight} alt="Rounding to nearest one error closer to odd right." />
  <ThemeImage src={exactEven} alt="Rounding to nearest one error closer to exact even." />
  <ThemeImage src={exactOdd} alt="Rounding to nearest one error closer to exact odd." />
  <ThemeImage src={halfwayAbove} alt="Rounding to nearest one error halfway above." />
  <ThemeImage src={halfwayBelow} alt="Rounding to nearest one error halfway below." />
</CardGrid>

We denote the absolute error from the true floating point value by $\Delta\text{ulp}$. A $\Delta\text{ulp}$ of 0.5 indicates that the value is 0.5 ulps away from the correct floating point value because it is not representable as, e.g., a 64 bit floating point number.

:::caution[Conservative Rounding]
This is rather conservative form of rounding.
Consider upper-bounding for the scenario in the bottom-right picture: It assumes that even if the output value is halfway between an odd value -1 (below) and an even value 0 (above) that it could end up landing at 1 (above) as the reference of CUDA does not specify anything beyond the max. error for most functions.
The function output could, however, also land on -1, in which case we must round upwards once.
Since we do not make any assumption as to when either scenario happens, rounding upwards is always performed, leading to
a maximum error of 2.5 ulps.
:::

So,
$$|\inf(F_{\text{analytic}}(X)) - \inf(F(X))| \leq 2.5 \text{ ulps}$$
is what we guarantee in this case.
