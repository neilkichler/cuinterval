# SPDX-License-Identifier: MIT
# Test generator from ITL test cases. Requires Python 3.9+

import glob
import re
import sys
import os

from collections import defaultdict

indent_one = ' ' * 4
indent_two = ' ' * 8
indent_three = ' ' * 12

auto_generated_comment_base = 'NOTE: This file is automatically generated by test_converter.py using itl tests.\n'
auto_generated_comment = '// ' + auto_generated_comment_base
auto_generated_comment_cmake = '# ' + auto_generated_comment_base

I = 'I' # interval
B = 'B' # boolean
T = 'T' # type
N = 'N' # number

supported = {
    "pos": {"args": [I], "ret": I, "ulp_error": 0},
    "neg": {"args": [I], "ret": I, "ulp_error": 0},
    "add": {"args": [I, I], "ret": I, "ulp_error": 0},
    "sub": {"args": [I, I], "ret": I, "ulp_error": 0},
    "mul": {"args": [I, I], "ret": I, "ulp_error": 0},
    "div": {"args": [I, I], "ret": I, "ulp_error": 0},
    "recip": {"args": [I], "ret": I, "ulp_error": 0},
    "sqr": {"args": [I], "ret": I, "ulp_error": 0},
    "sqrt": {"args": [I], "ret": I, "ulp_error": 0},
    "fma": {"args": [I, I, I], "ret": I, "ulp_error": 0},
    "mig": {"args": [I], "ret": T, "ulp_error": 0},
    "mag": {"args": [I], "ret": T, "ulp_error": 0},
    "wid": {"args": [I], "ret": T, "ulp_error": 0},
    "inf": {"args": [I], "ret": T, "ulp_error": 0},
    "sup": {"args": [I], "ret": T, "ulp_error": 0},
    "mid": {"args": [I], "ret": T, "ulp_error": 0},
    "rad": {"args": [I], "ret": T, "ulp_error": 0},
    "floor": {"args": [I], "ret": I, "ulp_error": 0},
    "ceil": {"args": [I], "ret": I, "ulp_error": 0},
    "abs": {"args": [I], "ret": I, "ulp_error": 0},
    "min": {"args": [I, I], "ret": I, "ulp_error": 0},
    "max": {"args": [I, I], "ret": I, "ulp_error": 0},
    "trunc": {"args": [I], "ret": I, "ulp_error": 0},
    "sign": {"args": [I], "ret": I, "ulp_error": 0},
    "intersection": {"args": [I, I], "ret": I, "ulp_error": 0},
    "convexHull": {"args": [I, I], "ret": I, "ulp_error": 0},
    "equal": {"args": [I, I], "ret": B, "ulp_error": 0},
    "subset": {"args": [I, I], "ret": B, "ulp_error": 0},
    "interior": {"args": [I, I], "ret": B, "ulp_error": 0},
    "disjoint": {"args": [I, I], "ret": B, "ulp_error": 0},
    "isEmpty": {"args": [I], "ret": B, "ulp_error": 0},
    "isEntire": {"args": [I], "ret": B, "ulp_error": 0},
    "less": {"args": [I, I], "ret": B, "ulp_error": 0},
    "strictLess": {"args": [I, I], "ret": B, "ulp_error": 0},
    "precedes": {"args": [I, I], "ret": B, "ulp_error": 0},
    "strictPrecedes": {"args": [I, I], "ret": B, "ulp_error": 0},
    "isMember": {"args": [T, I], "ret": B, "ulp_error": 0},
    "isSingleton": {"args": [I], "ret": B, "ulp_error": 0},
    "isCommonInterval": {"args": [I], "ret": B, "ulp_error": 0},
    "cancelMinus": {"args": [I, I], "ret": I, "ulp_error": 0},
    "cancelPlus": {"args": [I, I], "ret": I, "ulp_error": 0},
    "roundTiesToEven": {"args": [I], "ret": I, "ulp_error": 0},
    "roundTiesToAway": {"args": [I], "ret": I, "ulp_error": 0},
    "cbrt": {"args": [I], "ret": I, "ulp_error": 1},
    "exp": {"args": [I], "ret": I, "ulp_error": 3},
    "exp2": {"args": [I], "ret": I, "ulp_error": 3},
    "exp10": {"args": [I], "ret": I, "ulp_error": 3},
    "expm1": {"args": [I], "ret": I, "ulp_error": 3},
    "log": {"args": [I], "ret": I, "ulp_error": 3},
    "log2": {"args": [I], "ret": I, "ulp_error": 3},
    "log10": {"args": [I], "ret": I, "ulp_error": 3},
    "log1p": {"args": [I], "ret": I, "ulp_error": 3},
    "sin": {"args": [I], "ret": I, "ulp_error": 2},
    "cos": {"args": [I], "ret": I, "ulp_error": 2},
    "tan": {"args": [I], "ret": I, "ulp_error": 3},
    "asin": {"args": [I], "ret": I, "ulp_error": 3},
    "acos": {"args": [I], "ret": I, "ulp_error": 3},
    "atan": {"args": [I], "ret": I, "ulp_error": 3},
    "atan2": {"args": [I, I], "ret": I, "ulp_error": 3},
    "sinh": {"args": [I], "ret": I, "ulp_error": 3},
    "cosh": {"args": [I], "ret": I, "ulp_error": 2},
    "cot": {"args": [I], "ret": I, "ulp_error": 4},
    "coth": {"args": [I], "ret": I, "ulp_error": 3},
    "tanh": {"args": [I], "ret": I, "ulp_error": 2},
    "asinh": {"args": [I], "ret": I, "ulp_error": 3},
    "acosh": {"args": [I], "ret": I, "ulp_error": 3},
    "atanh": {"args": [I], "ret": I, "ulp_error": 3},
    "sinpi": {"args": [I], "ret": I, "ulp_error": 3},
    "cospi": {"args": [I], "ret": I, "ulp_error": 3},
    "pown": {"args": [I, N], "ret": I, "ulp_error": 1},
    "pow": {"args": [I, I], "ret": I, "ulp_error": 1},
    "rootn": {"args": [I, N], "ret": I, "ulp_error": 2},
    "hypot": {"args": [I, I], "ret": I, "ulp_error": 0},
}

def convert_to_test(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            test_name = file_path.rsplit('.', 1)[0].replace('-', '_')
            tests = file.read()

            # remove C++ style block comments
            comments = re.compile(r'(/\*.*?\*/)', re.DOTALL)
            tests = comments.sub('', tests).split('testcase')

            code = ''
            code_preamble = auto_generated_comment + r'''

#include "../tests.h"
#include "../tests_common.h"
#include "../tests_ops.h"
#include "../tests_utils.h"

#include <omp.h>

void tests_''' + test_name + '''(cuda_buffer buffer, cudaStream_t stream, cudaEvent_t event) {
    using namespace boost::ut;

    using T = double;
    using I = cu::interval<T>;
    using B = bool;
    using N = int;

    T infinity = std::numeric_limits<T>::infinity();
    I empty    = { infinity, -infinity };
    I entire   = { -infinity, infinity };
    T NaN = ::nan("");
'''

            code_postamble ='}'

            largest_n = 0
            empty = '{empty}'
            entire = '{entire}'
            float_max = '0x1.FFFFFFFFFFFFFp1023'
            float_min = '-0x1.FFFFFFFFFFFFFp1023'
            
            def replace_min_and_max(v):
                return 'std::numeric_limits<T>::max()' if v == float_max else 'std::numeric_limits<T>::lowest()' if v == float_min else v

            for test in tests:
                if test[0] == '\n':
                    continue
                # get the first word as the name prefix of the test
                name, body = test.split(maxsplit=1)
                name = name.strip("test").strip('_')
                if name.endswith('dec'): # ignore decorated interval tests
                    continue

                body = body.replace('[ ', '[').replace('[', '{').replace(']', '}').replace(' ,', ',').replace(', ', ',').replace('=', ' ')
                ops = body.splitlines()[1:-2]
                ops = [op.lstrip() for op in sorted(ops)]

                subtests = defaultdict(list)
                for op in ops:
                    if op in ['', '}'] or '//' in op:
                        continue
                    new_op, body = op.split(maxsplit=1)
                    subtests[new_op].append(body[:-1].split())
                
                for instr, ops in subtests.items():
                    instr_len = len(ops[0])
                    vars = ['res', 'xs', 'ys', 'zs'][:instr_len]
                    vars = vars[1:] + vars[:1] # rotate ref to last place
                    n_vars = len(vars)
                    n_args = n_vars - 1
                    n_ops = len(ops)
                    var_codes = [''] * n_vars

                    if instr not in supported:
                        print(f'Skipping unsupported instruction: {instr}', file=sys.stderr)
                        continue

                    arg_types = supported[instr]['args']
                    var_types = arg_types
                    var_types.append(supported[instr]['ret'])
                    max_ulp_diff = supported[instr]['ulp_error']
                    test_code = indent_one + '{\n'
                    test_code += indent_two + 'char *h_buffer = buffer.host;\n'

                    for i in range(n_vars):
                        var_codes[i] = indent_two + f'{var_types[i]} *h_{vars[i]} = new (h_buffer) {var_types[i]}[n]{{\n'

                    var_codes[-1] = var_codes[-1][:-1] + "};\n"

                    var_codes[n_args] += indent_two + f'std::array<{var_types[n_args]}, n> h_ref {{{{\n'
                    for elements in ops:
                        for i, el in enumerate(elements):
                            var_codes[i] += indent_three
                            if el == empty:
                                var_codes[i] += 'empty,\n'
                            elif el == entire:
                                var_codes[i] += 'entire,\n'
                            elif el[0] != '{':
                                var_codes[i] += f'{el},\n'
                            else:
                                vals = el[1:-1].split(',')
                                vals = [replace_min_and_max(v) for v in vals]
                                elements[i] = f'{{{vals[0]},{vals[1]}}}'

                                var_codes[i] += f'{el},\n'

                    cuda_code = ''
                    for i in reversed(range(n_vars)):
                        extra = '}' if i == n_vars-1 else ''
                        var_codes[i] += indent_two + extra + '};\n\n'
                        var_codes[n_args] += indent_two + f'{var_types[i]} *d_{vars[i]} = ({var_types[i]} *)d_{vars[i]}_;\n'

                    for i in range(1, n_vars):
                        var_codes[i-1] += indent_two + f'h_buffer += align_to(n * sizeof({var_types[i-1]}), alignof({var_types[i]}));\n'

                    for i in range(n_args):
                        cuda_code += indent_two + f'CUDA_CHECK(cudaMemcpyAsync(d_{vars[i]}, h_{vars[i]}, n*sizeof({var_types[i]}), cudaMemcpyHostToDevice, stream));\n'
                    
                    host_input_vars = ', '.join([ f'h_{vars[i]}' for i in range(n_args) ])
                    device_vars = ''.join([ f', d_{v}' for v in vars ])

                    cuda_code += indent_two + f'tests_{instr}_call(numBlocks, blockSize, stream, n{device_vars});\n'
                    cuda_code += indent_two + f'CUDA_CHECK(cudaMemcpyAsync(h_res, d_res, n*sizeof({var_types[n_args]}), cudaMemcpyDeviceToHost, stream));\n'
                    cuda_code += indent_two + 'CUDA_CHECK(cudaEventRecord(event, stream));\n'
                    cuda_code += indent_two + 'CUDA_CHECK(cudaEventSynchronize(event));\n'

                    cuda_code += indent_two + f'int max_ulp_diff = {max_ulp_diff};\n'
                    cuda_code += indent_two + f'check_all_equal<{var_types[n_args]}, n>(h_res, h_ref, max_ulp_diff, "{instr}", std::source_location::current(), {host_input_vars});\n'
                    cuda_code += indent_one + '};\n\n'

                    largest_n = max(n_ops, largest_n)
                    size_code = indent_two + f'constexpr int n = {n_ops};\n'
                    test_code += size_code
                    for var_code in var_codes:
                        test_code += var_code

                    test_code += cuda_code 
                    code += test_code

            code_constants = f'''
    const int n = {largest_n}; // count of largest test array
    const int n_bytes   = n * sizeof(I);
    const int blockSize = 256;
    [[maybe_unused]] const int numBlocks = (n + blockSize - 1) / blockSize;

    char *d_buffer = buffer.device;

    I *d_xs_  = (I *) d_buffer;
    I *d_ys_  = (I *) d_buffer + 1 * n_bytes;
    I *d_zs_  = (I *) d_buffer + 2 * n_bytes;
    I *d_res_ = (I *) d_buffer + 3 * n_bytes;\n\n'''

            if (code == ''):
                print(f'No operation supported in file: {file_path} -> skipping')
                return ''

            cpp_code = code_preamble + code_constants + code + code_postamble
            return cpp_code

    except FileNotFoundError:
        return f"File '{file_path}' not found."


def generate_kernel_wrappers(ops: dict):

    wrappers_cpp = auto_generated_comment + '#include "tests_ops.cuh"\n#include "tests_common.h"\n'
    wrappers_h = auto_generated_comment + '#include "tests_common.h"\n#include <cuinterval/interval.h>\n'

    template = {I: 'cu::interval<double>',
                B: 'bool',
                T: 'double',
                N: 'int'}


    for k, v in ops.items():
        instr_len = len(v['args']) + 1
        vars = ['res', 'xs', 'ys', 'zs'][:instr_len]
        vars = vars[1:] + vars[:1] # rotate ref to last place
        op_name = k

        input_args = ', '.join([ f'{template[arg]} *d_{vars[i]}' for i, arg in enumerate(v['args']) ])
        result_arg = f'{template[v["ret"]]} *d_res'
                    
        op_args = input_args + ', ' + result_arg

        kernel_declare = '''
void tests_''' + op_name + '''_call(int numBlocks, int blockSize, cudaStream_t stream,
                 int n, ''' + op_args + ')'

        device_vars = ''.join([ f', d_{v}' for v in vars ])
        kernel_body = '''
{
    test_''' + op_name + '''<<<numBlocks, blockSize, 0, stream>>>(n''' + device_vars + '''); 
}
            '''

        wrappers_cpp += kernel_declare + kernel_body
        wrappers_h += kernel_declare + ';\n'

    return wrappers_cpp, wrappers_h

if __name__ == '__main__':
    os.chdir(os.path.dirname(__file__) + '/itl')
    files = glob.glob('*.itl', recursive=True)

    kernel_wrappers_cpp, kernel_wrappers_h = generate_kernel_wrappers(supported)

    main_preamble = auto_generated_comment + '\n'

    # NOTE: for now we ignore floating point warnings for denormals
    main_pragmas_begin = '#ifdef __CUDACC__\n#pragma nv_diagnostic push\n#pragma nv_diag_suppress 1046\n#endif\n\n'
    main_pragmas_end = '\n#ifdef __CUDACC__\n#pragma nv_diagnostic pop\n#pragma nv_diag_default 1046\n#endif\n'
    main_includes = '#include "tests_generated.h"\n#include <omp.h>\n\n'
    main_declares = ''
    main_tests = ''

    for i, f in enumerate(files):
        test_code = convert_to_test(f)
        if test_code == '':
            continue
        f = f.replace('-', '_')
        tests_name = 'tests_' + f.rsplit('.', 1)[0]
        cpp_out_file = tests_name + '.cpp'
        with open(cpp_out_file, 'w') as f:
            f.write(test_code)
        # main_includes += f'#include "{out_file}"\n'
        main_declares += "void " + tests_name + '(cuda_buffer buffer, cudaStream_t stream, cudaEvent_t event);\n'
        main_tests += indent_three + f"#pragma omp task depend(inout:buffers[{i%4}].host,buffers[{i%4}].device)\n" + indent_three + tests_name + f'(buffers[{i%4}], streams[{i%4}], events[{i%4}]);\n'
        print('generated ' + cpp_out_file)

    for f in glob.glob('*.cu') + glob.glob('*.cpp'):
        os.replace(f, "../generated/" + f)

    os.chdir(os.path.dirname(__file__))

    with open('tests_ops.cu', 'w') as f:
        f.write(kernel_wrappers_cpp)

    with open('tests_ops.h', 'w') as f:
        f.write(kernel_wrappers_h)

    with open('generated/tests_generated.cpp', 'w') as f:
        main_body = f'''
void tests_generated(cuda_buffers buffers, cuda_streams streams, cuda_events events) {{
    #pragma omp parallel
    {{
        #pragma omp single nowait
        {{
{main_tests}
        }}
    }}
}}'''
        main_code = main_preamble + main_includes + main_declares + main_body
        f.write(main_code)

    # update the CMake list of the generated files
    with open('generated/tests.cmake', 'w') as f:
        generated_list = auto_generated_comment_cmake + 'set(generated_test_files\n' + '\n'.join([  indent_one + f for f in glob.glob('generated/*.cpp') ]) + '\n)\n'
        f.write(generated_list)

    print('Done!')

