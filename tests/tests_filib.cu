
#include <cuinterval/cuinterval.h>

#include "tests.h"
#include "test_ops.cuh"

#include <stdio.h>

template<typename T>
void tests_filib() {
    using namespace boost::ut;

    using I = interval<T>;

    I empty         = ::empty<T>();
    I entire        = ::entire<T>();
    T infinity = std::numeric_limits<T>::infinity();
    T NaN = ::nan("");

    const int n = 46; // count of largest test array
    const int n_bytes   = n * sizeof(I);
    const int blockSize = 256;
    [[maybe_unused]] const int numBlocks = (n + blockSize - 1) / blockSize;

    I *d_xs, *d_ys, *d_zs, *d_res_;

    CUDA_CHECK(cudaMalloc(&d_xs, n_bytes));
    CUDA_CHECK(cudaMalloc(&d_ys, n_bytes));
    CUDA_CHECK(cudaMalloc(&d_zs, n_bytes));
    CUDA_CHECK(cudaMalloc(&d_res_, n_bytes));

    "FI_LIB.addii_add"_test = [&] {
        constexpr int n = 19;
        std::array<I, n> h_xs {{
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X4.0000000000000P+0,-0X3.0000000000000P+0},
            {-0X5.0000000000000P+0,-0X4.0000000000000P+0},
            {-0XF.FFFFFFFFFFFF8P+1020,-0XF.FFFFFFFFFFFF8P+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X3.0000000000000P+0,0X4.0000000000000P+0},
            {0X4.0000000000000P+0,0X5.0000000000000P+0},
            {0XF.FFFFFFFFFFFF8P+1020,0XF.FFFFFFFFFFFF8P+1020},
        }};

        std::array<I, n> h_ys {{
            {-0X2.0000000000000P+0,-0X2.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X4.0000000000000P+0,-0X3.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,0X0.0000000000000P+0},
            {0X4.0000000000000P+0,0X5.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X2.0000000000000P+0,0X2.0000000000000P+0},
            {0X0.0000000000000P+0,0X1.0000000000000P+0},
            {0X3.0000000000000P+0,0X4.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {-0X5.0000000000000P+0,-0X4.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
        }};

        std::array<I, n> h_res{};
        I *d_res = (I *)d_res_;
        int n_result_bytes = n * sizeof(I);
        std::array<I, n> h_ref {{
            {-0X3.0000000000000P+0,-0X3.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {-0X5.0000000000000P+0,-0X3.0000000000000P+0},
            {-0X3.F400000000000P-1064,-0X3.F400000000000P-1064},
            {0XF.FFFFFFFFFFFF8P-4,0X1.0000000000000P+0},
            {-0X5.0000000000000P+0,-0X3.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0XF.FFFFFFFFFFFF8P+1020,-0XF.FFFFFFFFFFFF0P+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X3.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X3.0000000000000P+0,0X3.0000000000000P+0},
            {0X1.0000000000000P+0,0X3.0000000000000P+0},
            {0X4.0000000000000P+0,0X6.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000001P+0},
            {0X3.F400000000000P-1064,0X3.F400000000000P-1064},
            {0X4.0000000000000P+0,0X6.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {0XF.FFFFFFFFFFFF0P+1020,0XF.FFFFFFFFFFFF8P+1020},
        }};

        CUDA_CHECK(cudaMemcpy(d_xs, h_xs.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_ys, h_ys.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_res, h_res.data(), n_result_bytes, cudaMemcpyHostToDevice));
        test_add<<<numBlocks, blockSize>>>(n, d_xs, d_ys, d_res);
        CUDA_CHECK(cudaMemcpy(h_res.data(), d_res, n_result_bytes, cudaMemcpyDeviceToHost));
        auto failed = check_all_equal<I, n>(h_res, h_ref);
        for (auto fail_id : failed) {
            printf("failed at case %zu:\n", fail_id);
            printf("y = [%a, %a]\nr = [%a, %a]\n", h_ys[fail_id].lb, h_ys[fail_id].ub, h_ref[fail_id].lb, h_ref[fail_id].ub);
        }
    };

    "FI_LIB.subii_sub"_test = [&] {
        constexpr int n = 19;
        std::array<I, n> h_xs {{
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X4.0000000000000P+0,-0X3.0000000000000P+0},
            {-0X5.0000000000000P+0,-0X4.0000000000000P+0},
            {-0XF.FFFFFFFFFFFF8P+1020,-0XF.FFFFFFFFFFFF8P+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X3.0000000000000P+0,0X4.0000000000000P+0},
            {0X4.0000000000000P+0,0X5.0000000000000P+0},
            {0XF.FFFFFFFFFFFF8P+1020,0XF.FFFFFFFFFFFF8P+1020},
        }};

        std::array<I, n> h_ys {{
            {-0X2.0000000000000P+0,-0X2.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X4.0000000000000P+0,-0X3.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,0X0.0000000000000P+0},
            {0X4.0000000000000P+0,0X5.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X2.0000000000000P+0,0X2.0000000000000P+0},
            {0X0.0000000000000P+0,0X1.0000000000000P+0},
            {0X3.0000000000000P+0,0X4.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.0000000000000P+0,0X2.0000000000000P+0},
            {-0X5.0000000000000P+0,-0X4.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
        }};

        std::array<I, n> h_res{};
        I *d_res = (I *)d_res_;
        int n_result_bytes = n * sizeof(I);
        std::array<I, n> h_ref {{
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X2.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X4.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.0000000000001P+0,-0X1.0000000000000P+0},
            {-0X4.0000000000000P+0,-0X2.0000000000000P+0},
            {-0XA.0000000000000P+0,-0X8.0000000000000P+0},
            {-0XF.FFFFFFFFFFFF8P+1020,-0XF.FFFFFFFFFFFF0P+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {-0X2.0000000000000P+0,0X0.0000000000000P+0},
            {0X2.0000000000000P+0,0X2.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0XF.FFFFFFFFFFFF8P-4},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X3.0000000000000P+0},
            {0X8.0000000000000P+0,0XA.0000000000000P+0},
            {0XF.FFFFFFFFFFFF0P+1020,0XF.FFFFFFFFFFFF8P+1020},
        }};

        CUDA_CHECK(cudaMemcpy(d_xs, h_xs.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_ys, h_ys.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_res, h_res.data(), n_result_bytes, cudaMemcpyHostToDevice));
        test_sub<<<numBlocks, blockSize>>>(n, d_xs, d_ys, d_res);
        CUDA_CHECK(cudaMemcpy(h_res.data(), d_res, n_result_bytes, cudaMemcpyDeviceToHost));
        auto failed = check_all_equal<I, n>(h_res, h_ref);
        for (auto fail_id : failed) {
            printf("failed at case %zu:\n", fail_id);
            printf("y = [%a, %a]\nr = [%a, %a]\n", h_ys[fail_id].lb, h_ys[fail_id].ub, h_ref[fail_id].lb, h_ref[fail_id].ub);
        }
    };

    "FI_LIB.mulii_mul"_test = [&] {
        constexpr int n = 46;
        std::array<I, n> h_xs {{
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X2.0000000000000P+0,+0X5.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {-0X4.0000000000000P+0,+0X5.0000000000000P+0},
            {-0X5.0000000000000P+0,+0X2.0000000000000P+0},
            {-0X5.0000000000000P+0,+0X2.0000000000000P+0},
            {-0XF.FFFFFFFFFFFF8P+1020,-0XF.FFFFFFFFFFFF8P+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X2.0000000000000P+0},
            {0X0.0000000000000P+0,0X3.0000000000000P+0},
            {0X0.0000000000000P+0,0X3.0000000000000P+0},
            {0X0.0000000000000P+0,0X3.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0XF.FFFFFFFFFFFF8P+1020,0XF.FFFFFFFFFFFF8P+1020},
        }};

        std::array<I, n> h_ys {{
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {-0X4.0000000000000P+0,+0X3.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {-0X4.0000000000000P+0,+0X3.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X8.0000000000000P+0},
            {-0X4.0000000000000P+0,+0X3.0000000000000P+0},
            {0X8.0000000000000P-4,0X8.0000000000000P-4},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X8.0000000000000P-4,0X8.0000000000000P-4},
        }};

        std::array<I, n> h_res{};
        I *d_res = (I *)d_res_;
        int n_result_bytes = n * sizeof(I);
        std::array<I, n> h_ref {{
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X0.0000000000000P+0,0X4.0000000000000P-1076},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {-0X4.0000000000000P-1076,0X0.0000000000000P+0},
            {-0X1.4000000000000P+4,+0XF.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {0X4.0000000000000P+0,0X9.0000000000000P+0},
            {0X0.0000000000000P+0,0X9.0000000000000P+0},
            {-0X9.0000000000000P+0,0X0.0000000000000P+0},
            {-0X9.0000000000000P+0,-0X4.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {0X0.0000000000000P+0,0X9.0000000000000P+0},
            {-0X9.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.4000000000000P+4,+0X1.0000000000000P+4},
            {-0X2.8000000000000P+4,+0X1.0000000000000P+4},
            {-0XF.0000000000000P+0,+0X1.4000000000000P+4},
            {-0X7.FFFFFFFFFFFFCP+1020,-0X7.FFFFFFFFFFFFCP+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {-0X6.0000000000000P+0,0X0.0000000000000P+0},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {-0X9.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X9.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X0.0000000000000P+0,0X4.0000000000000P-1076},
            {-0X3.0000000000000P+0,+0X3.0000000000000P+0},
            {-0X9.0000000000000P+0,-0X4.0000000000000P+0},
            {-0X9.0000000000000P+0,0X0.0000000000000P+0},
            {-0X9.0000000000000P+0,0X0.0000000000000P+0},
            {0X4.0000000000000P+0,0X9.0000000000000P+0},
            {0X7.FFFFFFFFFFFFCP+1020,0X7.FFFFFFFFFFFFCP+1020},
        }};

        CUDA_CHECK(cudaMemcpy(d_xs, h_xs.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_ys, h_ys.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_res, h_res.data(), n_result_bytes, cudaMemcpyHostToDevice));
        test_mul<<<numBlocks, blockSize>>>(n, d_xs, d_ys, d_res);
        CUDA_CHECK(cudaMemcpy(h_res.data(), d_res, n_result_bytes, cudaMemcpyDeviceToHost));
        auto failed = check_all_equal<I, n>(h_res, h_ref);
        for (auto fail_id : failed) {
            printf("failed at case %zu:\n", fail_id);
            printf("y = [%a, %a]\nr = [%a, %a]\n", h_ys[fail_id].lb, h_ys[fail_id].ub, h_ref[fail_id].lb, h_ref[fail_id].ub);
        }
    };

    "FI_LIB.divii_div"_test = [&] {
        constexpr int n = 21;
        std::array<I, n> h_xs {{
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,+0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {-0X3.0000000000000P+0,0X0.0000000000000P+0},
            {-0XF.FFFFFFFFFFFF8P+1020,-0XF.FFFFFFFFFFFF8P+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X3.0000000000000P+0},
            {0X0.0000000000000P+0,0X3.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0XF.FFFFFFFFFFFF8P+1020,0XF.FFFFFFFFFFFF8P+1020},
        }};

        std::array<I, n> h_ys {{
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X2.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {-0X3.0000000000000P+0,-0X2.0000000000000P+0},
            {0X2.0000000000000P+0,0X3.0000000000000P+0},
            {0X2.0000000000000P+0,0X2.0000000000000P+0},
        }};

        std::array<I, n> h_res{};
        I *d_res = (I *)d_res_;
        int n_result_bytes = n * sizeof(I);
        std::array<I, n> h_ref {{
            {-0X8.0000000000000P-4,+0X8.0000000000000P-4},
            {-0X8.0000000000000P-4,+0X8.0000000000000P-4},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0XA.AAAAAAAAAAAA8P-4,0X1.8000000000000P+0},
            {-0X1.8000000000000P+0,-0XA.AAAAAAAAAAAA8P-4},
            {0X0.0000000000000P+0,0X1.8000000000000P+0},
            {-0X1.8000000000000P+0,0X0.0000000000000P+0},
            {-0X7.FFFFFFFFFFFFCP+1020,-0X7.FFFFFFFFFFFFCP+1020},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X0.0000000000000P+0},
            {-0X1.8000000000000P+0,0X0.0000000000000P+0},
            {0X0.0000000000000P+0,0X1.8000000000000P+0},
            {-0X1.0000000000000P+0,-0X1.0000000000000P+0},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.FA00000000000P-1064,-0X1.FA00000000000P-1064},
            {0X1.FA00000000000P-1064,0X1.FA00000000000P-1064},
            {0X1.0000000000000P+0,0X1.0000000000000P+0},
            {-0X1.8000000000000P+0,-0XA.AAAAAAAAAAAA8P-4},
            {0XA.AAAAAAAAAAAA8P-4,0X1.8000000000000P+0},
            {0X7.FFFFFFFFFFFFCP+1020,0X7.FFFFFFFFFFFFCP+1020},
        }};

        CUDA_CHECK(cudaMemcpy(d_xs, h_xs.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_ys, h_ys.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_res, h_res.data(), n_result_bytes, cudaMemcpyHostToDevice));
        test_div<<<numBlocks, blockSize>>>(n, d_xs, d_ys, d_res);
        CUDA_CHECK(cudaMemcpy(h_res.data(), d_res, n_result_bytes, cudaMemcpyDeviceToHost));
        auto failed = check_all_equal<I, n>(h_res, h_ref);
        for (auto fail_id : failed) {
            printf("failed at case %zu:\n", fail_id);
            printf("y = [%a, %a]\nr = [%a, %a]\n", h_ys[fail_id].lb, h_ys[fail_id].ub, h_ref[fail_id].lb, h_ref[fail_id].ub);
        }
    };

    "FI_LIB.unary_function_sqr"_test = [&] {
        constexpr int n = 29;
        std::array<I, n> h_xs {{
            {-0X1.2789C2D583BCDP-568,-0X1.F2BD89DAD0665P-780},
            {-0X1.32690AAC2472DP-40,-0X8.706EBDCF39C88P-792},
            {-0X1.7E13DBB66E5A3P-84,-0X6.BC8F45D6A8F48P-540},
            {-0X1.975299CCB0E08P-372,+0XB.BEC7D35B45B00P-588},
            {-0X1.9EE1A9DB994F5P-436,-0X6.D914701C82FECP-624},
            {-0X2.097D06F4DE3E2P-376,+0X2.2E7561FD9255EP-772},
            {-0X3.2C867C027DB44P-936,+0X6.1883EA827AB6CP-388},
            {-0X3.51D388D47AED2P-356,-0X1.C3A9CD7025105P-564},
            {-0X3.560EF91C47DEAP-492,+0X5.413664DD17ABCP-20},
            {-0X3.CF0053257533AP-776,-0X1.7883A587654E5P-928},
            {-0X4.1F50C5F2CDA54P-276,-0X3.DF16F79756422P-496},
            {-0X5.0145AF0C53324P-200,-0X2.F5A0CB3301856P-204},
            {-0X5.65057F3EFFC60P+4,-0X2.3617CF5815ECAP-960},
            {-0X6.3A58D52FDF844P-896,-0X1.039E2518CF503P-1008},
            {-0X6.BCEC84603958CP-500,-0X1.068B13DA99666P-760},
            {-0X7.ECC4C5EEC4CACP-328,-0X2.E02E1DB7A08F6P-876},
            {-0X8.36BFCD74A6D68P-304,-0X3.2C20EB130D510P-836},
            {-0X9.C46198B2471F0P-336,-0X1.65ED85DF2D4B7P-576},
            {-0XA.12F7783880A78P-124,-0X3.765DF69EE106EP-548},
            {-0XA.644C9D88EA8C8P-152,-0XD.8EC7927926F18P-944},
            {-0XB.B25F8D8BB7FB8P-376,-0X2.017A332F9B05CP-916},
            {-0XB.DD3171FDEEC18P-168,+0X1.069E434EE9E0FP-740},
            {-0XC.1BC7A4C89D440P-256,+0X2.A7F56252D1D34P-608},
            {-0XC.508D29ACB01B8P-52,+0X1.B1E6B793078DDP-664},
            {-0XC.DB363268CF708P-332,-0X2.171B7D7BFE4E0P-412},
            {-0XC.FE4E8D857E3E0P-548,+0X1.580844B9DC45CP-780},
            {-0XD.947CA427FDFE0P-592,+0XE.3BE493B5BC8E8P-16},
            {0X1.455801D3D2B63P-704,0X3.A4C915783D07AP-28},
            {0XF.4077C7E8CD6A0P-268,0X3.753426098AC5AP-80},
        }};

        std::array<I, n> h_res{};
        I *d_res = (I *)d_res_;
        int n_result_bytes = n * sizeof(I);
        std::array<I, n> h_ref {{
            {0X0.0000000000000P+0,0X4.0000000000000P-1076},
            {0X0.0000000000000P+0,0X1.6EBF489D48CA5P-80},
            {0X0.0000000000000P+0,0X2.3A3F453ECAFB4P-168},
            {0X0.0000000000000P+0,0X2.8817BFAFBDF18P-744},
            {0X0.0000000000000P+0,0X2.A05EA84E4893CP-872},
            {0X0.0000000000000P+0,0X4.264E23607BEA8P-752},
            {0X0.0000000000000P+0,0X2.52887FE100FF0P-772},
            {0X0.0000000000000P+0,0XB.051CC05C2EBE0P-712},
            {0X0.0000000000000P+0,0X1.B9CBC9B69E7BFP-36},
            {0X0.0000000000000P+0,0X4.0000000000000P-1076},
            {0XE.FCF2D2F52B4C0P-992,0X1.0FE5AD9038BC9P-548},
            {0X8.C23056BA480A8P-408,0X1.90CBA74D12CF4P-396},
            {0X0.0000000000000P+0,0X1.D1A144EFBEB44P+12},
            {0X0.0000000000000P+0,0X4.0000000000000P-1076},
            {0X0.0000000000000P+0,0X2.D668271745A42P-996},
            {0X0.0000000000000P+0,0X3.ECDBE373EAC94P-652},
            {0X0.0000000000000P+0,0X4.377B251ABDCC0P-604},
            {0X0.0000000000000P+0,0X5.F6582538F0F44P-668},
            {0X0.0000000000000P+0,0X6.57CBD208B34ACP-244},
            {0X0.0000000000000P+0,0X6.BFD4840B33478P-300},
            {0X0.0000000000000P+0,0X8.8D07F2E827770P-748},
            {0X0.0000000000000P+0,0X8.CC15E342FC8D8P-332},
            {0X0.0000000000000P+0,0X9.29DBB2B42A988P-508},
            {0X0.0000000000000P+0,0X9.7A69470135FA8P-100},
            {0X4.5E83E96FF693CP-824,0XA.548CA7F8C13A0P-660},
            {0X0.0000000000000P+0,0X4.0000000000000P-1076},
            {0X0.0000000000000P+0,0XC.A9B03500DD578P-28},
            {0X0.0000000000000P+0,0XD.46C8C24634FC8P-56},
            {0XE.89E458947EFA8P-532,0XB.F4E1999D73020P-160},
        }};

        CUDA_CHECK(cudaMemcpy(d_xs, h_xs.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_res, h_res.data(), n_result_bytes, cudaMemcpyHostToDevice));
        test_sqr<<<numBlocks, blockSize>>>(n, d_xs, d_res);
        CUDA_CHECK(cudaMemcpy(h_res.data(), d_res, n_result_bytes, cudaMemcpyDeviceToHost));
        auto failed = check_all_equal<I, n>(h_res, h_ref);
        for (auto fail_id : failed) {
            printf("failed at case %zu:\n", fail_id);
            printf("r = [%a, %a]\n", h_ref[fail_id].lb, h_ref[fail_id].ub);
        }
    };

    "FI_LIB.unary_function_sqrt"_test = [&] {
        constexpr int n = 30;
        std::array<I, n> h_xs {{
            {0X1.2C18FEEBCAEAEP-768,0X1.C369E759DF5E3P-328},
            {0X1.394270BBCBA7EP+196,0X8.4976F0BF45A40P+224},
            {0X1.3C84E4F9C80CEP-476,0X9.1E9439C3B4358P+196},
            {0X1.E139DD116F868P-688,0XD.2545346D68FD0P-148},
            {0X2.33950F38F830EP-176,0X5.BE0388619B018P-24},
            {0X2.6213E21B14894P-516,0X6.6606F0995E5F4P-224},
            {0X2.8E258DB3C44F8P+20,0X3.1A4EDE719A4C0P+628},
            {0X2.9CD12C1D0AAC4P+116,0X3.BF7E0E52DC1AAP+276},
            {0X2.D572639DC5FA8P-468,0X1.95CF42AA171CDP-160},
            {0X2.E0C8E64A890ACP+192,0X2.6A898D2CAA9A4P+260},
            {0X3.24F03DF33568CP-560,0XE.67255823421E8P+920},
            {0X3.36DE5C55594EEP-100,0X1.D0460177B1553P+204},
            {0X4.705A028302DB0P-532,0X2.E57341C14970CP+324},
            {0X4.9FA5A1E4DF740P-328,0X1.11B85141B78F6P-240},
            {0X4.BD4031736F7A8P+4,0XF.A10BB3C91C7B0P+592},
            {0X4.D94E91619D3F0P-580,0X2.9F6CAF6B5513EP-132},
            {0X4.DBA1D21D6F308P+144,0X3.667988C57865AP+196},
            {0X5.9C4642ED78BC8P-340,0X4.631BD2232F0C0P+588},
            {0X6.2085E427413C8P-252,0XB.8CDD3B024EA10P-36},
            {0X6.88441038D56B8P-108,0X3.3D65C09938132P+136},
            {0X6.A000A12839A50P-44,0X3.86DC59439415AP+276},
            {0X7.1761CAB055134P-356,0X1.92EFD09488689P-76},
            {0X8.41D2DB6D93548P-376,0X2.EDCF4A7919034P+140},
            {0X8.E2ADA8DFBE938P-492,0X3.67CB3BE0BB146P-452},
            {0X9.0FF2CAA1B3048P-240,0X1.95F14B9BA7449P+236},
            {0XA.0CDE9DC015B08P+360,0XF.99D84F862AC58P+524},
            {0XB.BC7E37EB2D388P-216,0X1.CFE27BB53DEBBP+192},
            {0XB.F5F1C0FA33978P-504,0X4.924DD8D50B1CCP+72},
            {0XC.4B4A6EB6B3AF0P-264,0XA.DD2C4C1BE4B30P+92},
            {0XF.C05EA810DFE88P-180,0XA.05884FBED5F48P-152},
        }};

        std::array<I, n> h_res{};
        I *d_res = (I *)d_res_;
        int n_result_bytes = n * sizeof(I);
        std::array<I, n> h_ref {{
            {0X1.152C585EDDB6AP-384,0X1.53F1A81CAA4A0P-164},
            {0X4.6CBEB2D8F6718P+96,0X2.E0F32319AC30AP+112},
            {0X4.729F7C344CE30P-240,0XC.14519D6697FF0P+96},
            {0X1.5EFD65C23F515P-344,0XE.80B36809CA340P-76},
            {0X1.7BD69462CDAD2P-88,0X2.6573BFB248EF0P-12},
            {0X6.2CC8B5D1B7648P-260,0X2.878F8E10E2752P-112},
            {0X6.64E1F64817930P+8,0X7.0BBE006E8934CP+312},
            {0X6.7722C88D985D8P+56,0X7.BE7173245A668P+136},
            {0X6.BBC8A036CC930P-236,0X1.4250C275A7B2BP-80},
            {0X1.B24CEBB3D4B84P+96,0X6.37B4CD9068634P+128},
            {0X1.C5F168118C2B1P-280,0X3.CB8CCAD62ED10P+460},
            {0X7.2BE248A308D24P-52,0X5.630224B50BCF8P+100},
            {0X8.6D6D9A3EA2160P-268,0X6.CEB17F56F1B50P+160},
            {0X2.26777C4E368BEP-164,0X1.08B63617A4210P-120},
            {0X8.B53B61217B4F8P+0,0X3.F40FA54A699E2P+296},
            {0X8.CEDC2135E05E8P-292,0X6.7A5BEF2579C34P-68},
            {0X2.343E215EB2264P+72,0X7.603E67F0E1DD0P+96},
            {0X9.797C4D6802170P-172,0X8.60D1F01F1A8D8P+292},
            {0X9.E6B17DD90B818P-128,0XD.9821AE0A3F288P-20},
            {0XA.392C9B2283838P-56,0X1.CCC9C68E6B873P+68},
            {0XA.4BAEE7F482900P-24,0X7.830C8D5A5F3D8P+136},
            {0XA.A6DE001E1A878P-180,0X5.04B0B42B185F4P-40},
            {0X2.DF9F14A64C77AP-188,0X6.D87D667089BD8P+68},
            {0XB.EC63BFE10BCC8P-248,0X7.61AC89CF17804P-228},
            {0X3.02A74AB0BBF36P-120,0X5.0979194446A10P+116},
            {0X3.2B934CDCC29E0P+180,0XF.CC99981010AD0P+260},
            {0X3.6D0318CB65970P-108,0X1.589B93C7CC280P+96},
            {0X3.755B7F9B147FCP-252,0X2.235AF64AA2532P+36},
            {0X3.819C8C44FCAE8P-132,0XD.2F2830FA93228P+44},
            {0XF.E00F72E6C82F8P-92,0X3.2A6AD8ACFCBB0P-76},
        }};

        CUDA_CHECK(cudaMemcpy(d_xs, h_xs.data(), n_bytes, cudaMemcpyHostToDevice));
        CUDA_CHECK(cudaMemcpy(d_res, h_res.data(), n_result_bytes, cudaMemcpyHostToDevice));
        test_sqrt<<<numBlocks, blockSize>>>(n, d_xs, d_res);
        CUDA_CHECK(cudaMemcpy(h_res.data(), d_res, n_result_bytes, cudaMemcpyDeviceToHost));
        auto failed = check_all_equal<I, n>(h_res, h_ref);
        for (auto fail_id : failed) {
            printf("failed at case %zu:\n", fail_id);
            printf("r = [%a, %a]\n", h_ref[fail_id].lb, h_ref[fail_id].ub);
        }
    };


    CUDA_CHECK(cudaFree(d_xs));
    CUDA_CHECK(cudaFree(d_ys));
    CUDA_CHECK(cudaFree(d_zs));
    CUDA_CHECK(cudaFree(d_res_));
}
